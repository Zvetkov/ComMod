## Доступные типы merge-команд
Вернёмся к первому примеру команды из вводной статьи:

* *_uidescription.xml:*
```xml
<?xml version="1.0" encoding="windows-1251" standalone="yes" ?>
<resource>
    <string
        _Action="Add"
        _SelectorKeys="id"
        id="bulldogCab01_diz"
        value="Первая кабина Бульдога, совершенно недостаточное вооружение, но высокая скорость частично компенсирует нехватку огневой мощи."/>
</resource>
```

Поле **_Action** определяет тип команды. 

Разберёмся какие бывают типы команд и что они означают:

|Команда                          |Тип                                |
|---------------------------------|-----------------------------------|
|**AddOrReplace**                 | Мягкое добавление ИЛИ замена      |
|**Modify**                       | Мягкое редактирование             |
|**Remove**                       | Мягкое удаление                   |
|**Add**                          | Строгое добавление                |
|**Replace**                      | Строгая замена                    |
|**ModifyOrFail**                 | Строгое редактирование            |
|**RemoveOrFail**                 | Строгое удаление                  |

Порядок перечисления тут не совсем случаен. Не все команды одинаково полезны, не все они нужны в большинстве модов.
Наш автоматический диффер, инструмент создания списка команд на основе разницы между двумя xml файлами, производит только верхние 4 типа команд: AddOrReplace, Add, Modify, Remove.

В общем смысле: 
* "Мягкая" команд, в случае неопределённой ситуации, обычно продолжает установку тем или иным образом
* "Строгая" команда, если не удаётся её выполнить, оборвёт установку мода, сообщив о её невозможности

Некоторые, особенно строгие варианты, будут нужды довольно редко. Но они всё равно доступны, чтобы дать моддерам выбор.

### Важное примечание!
Все рассуждения о конфликтах мержа - теоретические. Правильно оформленный для установки мод, может самостоятельно указать с чем он совместим, а с чем - нет. 

Если сюжетный мод stranded уже включает в себя машины из мода ExtraMachines и они являются обязательными для его работы - логично что на него не нужно отдельно ставить ExtraMachines. ExtraMachines в такой ситуации имеет смысл указать stranded как несовместимый мод.

Однако, не всегда моддеры будут следить за тем где и как переиспользуется контент в других модах. В таком случае, контентные merge-моды могут быть не слишком строгими с требованиями к игре, например, разрешая установить один мод с новыми машинами поверх другого мода с новыми машинами, или установить один и тот же аккуратно сделанный новый квест и на КомРем и на ImprovedStoryline. При этом, в случае реальной несовместимости ComMod позаботится о том, чтобы установка мода не сломала игроку игру, особенно в ситуации, где конфликт правок был очевиден. 

## Логика автоматического диффера на примере команд добавления
Вернёмся к работе диффера, она подскажет как нам самим создавать команды, если захотим (и как редактировать результаты автоматического диффера, что вероятнее).

Найденные новые уникальные ноды (прототипы машин, описания объектов, триггеры и т.д.) - диффер создаёт как строгий **Add**. 

Логика в том что если наш мод контентный, и добавляет новые объекты, он не ожидает встретить те же самые объекты в файлах игры. Если мод добавляющий грузовик ЗИЛ-130 в игру, встречает в игре уже существующий прототип этого грузовика, вероятно, что любой вариант установки приведёт если не к багам и вылетам, то как минимум к бесполезному перезаписыванию файлов и неконсистентному отображению машины в игре. Лучше остановить установку и сообщить юзеру о конфликте.

Найденные новые НЕ уникальные ноды (товары в магазинах, кабины и кузова в мастерских, возможные группы спавна машин в инфекшн зонах и т.д.) - диффер создаёт как **AddOrReplace**. Для не уникальных объектов, диффер сперва считает их количество в обоих файлах. Например, в первом файле в мастерской Южного прописаны 2 одинаковые кабины Вена, а в моде автор решил добавить ещё один. Диффер заметит разницу в числе одинаковых объектов и произведёт команду **AddOrReplace**, задействовав однако ещё одно специальное поле, которое мы ранее не рассматривали - **_DesiredCount**. Буквально "желаемое число" объектов. Логично предположить, что целью мода было видеть в магазине 3 варианта кабины Вена, с разными рандомными характеристиками. Поэтому вместо попытки буквально трактовать разницу как "мод добавляет ещё одну кабину Вена", мы трактуем её как "мод хочет видеть в магазине 3 кабины Вена". _AddOrReplace команда с DesiredCount=3 даст нам именно такой результат.
Если бы в магазине изначально не было ни одной кабины Вена, а в моде - три, команда была бы ровно той же. Команда гибко отработает в обоих случаях. Если в магазине уже была одна кабина - добавит ещё две. Если их было четыре - удалит одну. Если их было две - добавит ещё одну.

А вот пример настоящей команды которые произведёт диффер:

* *_dynamicscene_r1m1.xml:*
```xml
<Item
   _Action="AddOrReplace"
   _ParentXPath="Object[@Name='TheTown']/Object[@Name='TheTown_Workshop']/CabinsAndBaskets"
   _SelectorKeys="Prototype"
   _DesiredCount="3"
   Prototype="bugCab02"/>
```
Воу, это ещё что такое? **_ParentXPath**, ещё одно техническое поле, выглядит устрашающе!

Все команды что мы добавляем находятся на самом нижнем уровне документа, прямо в его корневом теге. Для файлов с плоской структурой, таких как `uidescription.xml`, в этом нет ничего удивительного. Но `dynamicscene.xml` это другое дело. Города в нём это глубокая структура (ещё говорят "вложенная структура"), внутри города есть объект бара, объект мастерской и т.д. 
Для того чтобы указать куда именно мы хотим добавить объект в такой ситуации, нам нужно указать путь к его родительскому ноду.
Автоматика это делает за нас, генерируя **_ParentXPath**.

Синтаксис тут не случайный и не выдуман нами только для Махины. Это так называемый XPath, который позволяет найти любой элемент в структуре xml по его тегу и полям (а на самом деле и не только по ним).

> Object[@Name='TheTown']/Object[@Name='TheTown_Workshop']/CabinsAndBaskets

При применении этой команды, ComMod, отталкиваясь от корня документа:
1) Найдёт нод с тегом Object и полем Name="TheTown" (город Южный)
2) В его дочерних нодах найдёт нод Object с Name="TheTown_Workshop" (мастерская Южного)
3) В его дочерних нодах найдёт нод с тегом CabinsAndBaskets (список кабин и кузовов мастерской Южного)

В большинстве случаев эти **_ParentXPath** нам не понадобится писать вручную, за нас их сгенерирует диффер.
В случае если всё же захочется самому написать путь - по этому примеру и другим примерам, сгенерированным диффером, несложно научиться как (так же можно поискать в сети "синтаксис XPath").

## Команды изменения
Фух, разобрались ещё только с добавлением, а уже куча нового. Суммаризуем:
* Тип команды определяется полем **_Action**
* Чтобы понять какой нод мы хотим менять и для определения его уникальности, используется **_SelectorKeys**
* Если наш редактируемый\добавляемый\удаляемый нод находится не в корневом теге, ему нужно указать **_ParentXPath**

Продолжим!

Мы знаем что делает диффер когда видит новый уникальный нод, или изменения числа "копий" для не уникальных нодов (таких как товары в мастерской).
Но часто в моддинге мы просто меняем одно или несколько полей существующего нода. Например меняем характеристику уже существующей машины, как делает мод OverPhys для перенастройки физики машин. Посмотрим какие команды диффер сформирует для нас в такой ситуации:

Для грузовичка Вена исходный нод выглядит так:

* *gamedata\gameobjects\vehicles.xml:*

```xml
<Prototype
    Class="Vehicle"
    Name="Bug"
    ResourceType="VEHICLE"
    DiffRatio="3.0"
    MaxEngineRpm="6000"
    LowGearShiftLimit="3000"
    HighGearShiftLimit="3300"
    SelfBrakingCoeff="0.006"
    SteeringSpeed="0.8"
    HornSound="ET_S_HORN01"
    PressingForce="2.0"
    CameraHeight="4.66"
    CameraMaxDist="20"
    DecisionMatrix="vehiclemain.lua"
    LookRadius="200.0"
    IntersectionRadius="4.5"
    TakingRadius="30.0"
    DestroyEffectPiercing="ET_PS_VEH_EXP1_MED"
    DestroyEffectBlast="ET_PS_VEH_EXP2_MED"
    DestroyEffectEnergy="ET_PS_VEH_EXP3_MED"
    DestroyEffectWater="ET_PS_VEH_EXP2_MED"
    MassSize="3 2 8"
    MassTranslation="0 -0.5 0"
    DriftCoeff="0.06"
    Abstract="true">

    <MainPartDescription id="CHASSIS" partResourceType="BUG_CHASSIS">
        ...
    </MainPartDescription>

    <Parts>
        <Part id="CHASSIS" Prototype="bugChassis" />
    </Parts>

    <Wheels>
        ...
    </Wheels>

</Prototype>
```

А сформированная диффером команда, после сравнения исходного нода и файла из мода так:

```xml
<Prototype
   _Action="Modify"
   _SelectorKeys="Name"
   Name="Bug"
   PressingForce="1.0"
   MassTranslation="0 -0.1 0"
   DriftCoeff="0.99"
   AdditionalWheelsHover="0.1"/>
```

Мы видим знакомые технические поля, благодаря которым понятно что целевым нодом для изменения будет нод с тегом **Prototype** и полем **Name="Bug"**. Для этого нода команда поменяет поля PressingForce, MassTranslation, DriftCoeff и AdditionalWheelsHover.

Команда **Modify** - "мягкая", значит если вдруг по какой-то причине целевой нод не будет найден в игре, команда будет пропущена, не прерывая дальнейшую установку. Это разумно для мода меняющего физику машин, ведь ничего страшного не произойдёт если какой-то машины что мы ребалансим не оказалось в базовой игре, даже в худшем случае в игре будет несколько машин с чуть разной физикой.

Однако, рассмотрим другие примеры. Что если мы сравним `triggers.xml` между крупными модами, такими как ComRem и ISL?

Здесь мы видим разницу во внутренней логике диффера. Несмотря на то что часть триггеров отредактированы в ISL, для триггеров диффер производит команду **AddOrReplace**, а не **Modify**:

Исходный триггер:

```xml
<trigger
    Name="GlobalVar"
    active="1">
    <event timeout="0.1" eventid="GE_TIME_PERIOD"/>

    <script>
        trigger:Deactivate()
    </script>
</trigger>
```

Команда сформированная диффером:

```xml
<trigger
    _Action="AddOrReplace"
    _SelectorKeys="Name"
    Name="GlobalVar"
    active="1">
    <event timeout="0.1" eventid="GE_TIME_PERIOD"/>

    <script>
        SetVar("FelixRevenge",0)
        SetVar("FelixChoise",0)
        SetVar("DrunkRide", 0)
        SetVar("AutoSaveCount", 0)
        SetVar("DestroyedSowth", 0)
        if ISL_VERSION then SetVar("ISLVersion", ISL_VERSION) end

        if getObj("Ruin") then
            SetVar("KrayCity", 1)
            LOG("KRAYCITY ADDON IS INSTALLED.")
        else
            SetVar("KrayCity", 0)
            LOG("KRAYCITY ADDON IS NOT INSTALLED.")
        end

        trigger:Deactivate()
    </script>
</trigger>
```

Чтобы не загромождать страницу опустим цитату полного модифицированного нода, скажем только что по сути он один в один соответствовал команде, если из неё убрать технические поля.

Логика тут следующая - изменение триггеров это деструктивная правка, которая не терпит неточности. Диффер предпочитает полную замену или добавление простому изменению дочернего нода **script**, поэтому по-умолчанию будет создана команда **AddOrReplace**. В некоторых ситуациях стоит использовать даже строгие варианты коман.

**Add** пригодится, например, если наш сюжетный мод добавляет триггер использующийся только в нашем квесте. Если такой триггер уже существует, из-за неудачного выбора имени и конфликта имён или по другой причине, вероятно нет смысла заменять его нашей логикой, ведь мы не знаем для чего триггер используется в этой копии игры.

А **Replace**, если наш мод редактирует один из триггеров оригинала или базового мода как точку входа для собственной логики, при том полагаясь на дальнейшие триггеры другого мода для корректной работы. Например мы подменили триггер, где генерируется награда за существующий квест. Если этот квест не существует - нет никакого смысла делать **Add**, лучше сразу остановить установку.

## Команды удаления

Ситуация с командами удаления наверное самая простая в плане оформления, но довольно сложная в другом аспекте. А именно в аспекте выбора моддеров ситуаций когда вообще нужно что-то удалять.

> Золотое правило любого merge-мода: не надо менять ноды которые не обязательно менять.

И в первую очередь это касается именно удаления.

Добавляете новую машину в продажу? Большой соблазн перебалансить выбор машин в городе и убрать оттуда что-то что там уже есть. Но, подумайте так ли это нужно. Нужно? Хорошо, тогда имеет смысл хотя бы перетащить ребаланс в отдельную опцию мода, можно так и назвать её, ребаланс.

Хотите удалить старую строку из энциклопедии, или удалить ненужный прототип машины, который не спавнится в вашем моде? Опять же, подумайте не сломаете ли вы этой безобидной "чисткой" что-то ещё в абсолютно другом моде.

Однако, есть ситуации когда удалять что-то необходимо. Более того, есть ситуации и в который лучше вместо создания merge-команд предоставить в моде полный файл, например dynamicscene или triggers. В особенности это нормально для крупных сюжетных модов. 

Новая система позволяет даже очень большим модам работать без полной замены файлов, но иногда в этом просто нет смысла. Если мод очень сильно перелопатил карту, поменял дороги, ландшафт, города и реки - скорее всего merge-инструкция будут слишком громоздкой, слишком глобальной чтобы от неё была польза. С другой стороны, лишь очень редкий мод, например тотал-конвершн в духе Армады, выигрывает от полной замены файла описаний в энциклопедии.

Чтож, это всё философия. Рассмотрим и два практических примера:

* *r1m1\triggers.xml:*

```xml
<trigger
    _Action="Remove"
    _SelectorKeys="Name"
    Name="trFirstRolik"/>
```
 
ISL удаляет триггер **trFirstRolik** в triggers.xml. Зачем? Потому что триггер был перемещён в *r1m1\cinematriggers.xml*. В случае создания нового мода с merge-командами, такая правка была бы не слишком удачной, придерживаясь золотого правила, названного выше. Но ISL - базовый мод, который, вероятно, всегда будет предоставлять свои собственные полные копии triggers.xml, dynamiscene.xml и подобных файлов.

Поэтому, единственный урок который мы можем из этого извлечь, это то что моду, который хочет быть совместимым с несколькими крупными базовыми модами, например и с ComRem, и с ISL, нужно учитывать такие вещи при редактировании их ресурсов.

Например, моды на новые машины любят заменять стартовую машину игрока. Стартовая машина игрока в оригинальной игре задётся в **dynamicscene.xml** карты *r1m1*:
 
```xml
    <Object
        Name="Player1"
        Belong="1100"
        Prototype="player"
        Money="100">
        <Object
            Name="MyCar"
            Belong="1100"
            Prototype="Bug01"
            Pos="3355.000 368.500 3308.000"
            Rot="-0.007 1.000 -0.010 0.021">
            <Parts />

            <Repository />
        </Object>
    </Object>
```
 
Но в ISL, в этом месте задана машина едущая по Краю в первой катсцене, т.е. машина Лисы.
А вот машина игрока задаётся в триггере **trOpeningEnd** в *cinematriggers.xml*.

Соответственно, если базовая часть мода меняет машину игрока в динамиксцене, через редактирование dynamicscene, в опции включающей поддержку ISL надо будет вернуть на место машину в динамиксцене, а поменять её уже через редактирование соответствущего триггера:

```xml
<triggers>
    <trigger
        _Action="AddOrReplace"
        _SelectorKeys="Name"
        Name="trOpeningEnd"
        active="0">
        <event flypath="Opening_End" eventid="GE_START_CINEMATIC_FLY" ObjName="Player1"/>

        <script>
            AddPlayerNewVehicle("ChevC10Player")
            local vehPlayer = GetPlayerVehicle()
            if vehPlayer then
                vehPlayer:SetGamePositionOnGround( CVector(3355.000, 368.500, 3308.000))
                vehPlayer:SetRotation(Quaternion(-0.007, 1.000, -0.010, 0.021))
                vehPlayer:SetSkin(0)
                vehPlayer:UnlimitMaxSpeed()
                vehPlayer:SetBelong(1100)
            end

            trigger:Deactivate()    
        </script>
    </trigger>
```
