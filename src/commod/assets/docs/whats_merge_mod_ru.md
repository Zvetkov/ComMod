## Что такое merge-моды

Стандартные моды в Ex Machina работают через полную замену модифицированными файлами стандартных файлов игры.
Это серьёзно усложняет создание совместимых между собой модов меняющих одни и те же файлы.

Идея merge-модов (далее "мерж-моды"), в том чтобы сделать возможным в файлах мода хранить правки игры в виде "команд", смысл которых например:
* отредактировать первую кабину Урала и поменять ей скорость
* добавить локализованное название для новой машины на базе Бойца

Хотя будем чуть более точны в инструкции, более практичны:

* "в файле vehicleparts.xml найди прототип с именем "uralCab01" и проставь ему характеристику MaxSpeed = 140"
* "в файле uidescription.xml найди запись с id "Fighter02_diz", если она уже есть - замени на "Крутой боец", если нет - добавь новую запись с этим описанием
* "в файле triggers.xml карты r1m1, замени триггер "trFirstRolik" на мой новый триггер"
* "в файле dynamicscene.xml карты r1m2 удали из магазина "Esting_Workshop" (города Восточный) все кузова для Вена под именем "bugCargo03"
* "в том же файле замени NPC "Fermer" стартовые диалоги на значение, содержащее начало нового квеста - helloReplyNames="Fermer_hellodlg0 Fermer_SuperMod_NewQuest"
* и так далее

ComMod и ранее поддерживал функционал упрощающий установку нескольких модов вместе, сперва через систему требований к базовым модам, а позже через упаковку в один архив нескольких "вариантов" мода. Однако, каждый вариант для совместимости с другим модом всё равно требовал ручного совмещения. Даже в случае если автор мода решился на создание нескольких вариантов, процесс всё равно сложный, порты требуют обновлений после каждого даже небольшого обновления своих базовых модов и в целом ручной процесс совмещения легко приводит к ошибкам - либо ломающим оба мода, либо перезатирающим часть изменений базового мода без особой причины.

Merge-моды - это инструмент упрощения создания совместимых модов, да и в целом любых модов. 

Давая возможность изменить отдельный игровой объект, и позволяя модам содержать информацию только о значимых изменениях, не копируя всё остальное, что они не затрагивают. В текущей версии, ComMod поддерживает совмещение xml файлов (и ssl файлов, по своей сути тоже xml). 

Помимо основной цели увеличения совместимости модов, работа с merge-модом в целом выглядит чище и аккуратнее, возможно делая приятнее работу даже над модами авторам, которые не особо заинтересованы совместимостью.

Как понятно из примера в начале, мерж-моды работают благодаря мерж-командам, "инструкциям", описывающим как игровые объекты должны быть добавлены, изменены или удалены.

В этой вводной статье, для наглядности, рассмотрим пару примеров.

Если описания выше были написаны понятным человеку языком, команды понятные ComMod будут похожи на игровые ресурсы, которые они добавляют или меняют, но с некоторыми дополнительными данными.

### Первые примеры

Для некоторых объектов, включая машины, их части, и разные виды оружия, в игре есть описания этих объектов в "Энциклопедии", разделе игрового журнала. 

Описания предметов в энциклопедия хранятся в файле `data/if/strings/uidescription.xml`. Файл выглядит примерно так:

```xml
<?xml version="1.0" encoding="windows-1251" standalone="yes" ?>
<resource>
  ...
    <string
        id="uralCab04_diz"
        value="Стандартная кабина, подготовленная для боевых действий. Улучшенная броня. Два слота под оружие." />

    <string
        id="uralCab05_diz"
        value="Эта кабина содержит наибольшее число модификаций. Броня, вооружение, мощность, скорость." />

    <string
        id="belazCab01_diz"
        value="Самая дешевая и простая кабина для Белаза. Можно поставить маленькую пушку и несколько устройств улучшения." />
  ...
</resource>
```

В полноценном файле вместо многоточий будут перечислены ещё десятки и сотни объектов. Без мерж-команд, чтобы добавить в игру новую машину, квестовый предмет или единицу оружия, моддеру нужно хранить полную копию этого файла и дописывать в него новые описания.

Например так:

```xml
<?xml version="1.0" encoding="windows-1251" standalone="yes" ?>
<resource>
  ...
    <string
        id="uralCab04_diz"
        value="Стандартная кабина, подготовленная для боевых действий. Улучшенная броня. Два слота под оружие." />

    <string
        id="uralCab05_diz"
        value="Эта кабина содержит наибольшее число модификаций. Броня, вооружение, мощность, скорость." />

    <string
        id="belazCab01_diz"
        value="Самая дешевая и простая кабина для Белаза. Можно поставить маленькую пушку и несколько устройств улучшения." />

    <!-- Новое описание для bulldogCab01 -->
    <string
        id="bulldogCab01_diz"
        value="Первая кабина Бульдога, совершенно недостаточное вооружение, но высокая скорость частично компенсирует нехватку огневой мощи." />
  ...
</resource>
```

Мерж-мод позволяет решить эту задачу по другому.

Мод содержит только специальную инструкцию (или множество инструкций), которые указывают как ComMod должен поменять файлы игры.

Понятное человеку описание звучала бы как:
* "в файле uidescription.xml найди запись с id "bulldogCab01_diz", если она уже есть - замени на "Первая кабина Бульдога...", если нет - добавь новую запись с этим описанием

Раскручивая это описание в понятное установщику инструкцию, понимаем что нам нужно сперва указать где хранятся инструкции, и к чему это инструкции относятся. В манифесте мода рядом с указанием data_dirs, папок которые нужно просто скопировать, добавим новый пункт:
```yaml
...
data_dirs:
  - "data"
merge_instructions:
  - "merge_instructions_bulldog.yaml"
...
```
В файле `merge_instructions_bulldog.yaml` мы укажем к какому файлу применять какой набор команд. В этот раз создадим его просто в корневой папке мода.

Пункт **merge_instructions** можно добавить в основной части манифеста мода, чтобы команды применялись всегда, а можно в **optional_content**'е мода, чтобы какие-то команды применялись только при выборе опции установки мода пользователем.


Инструкции задаются в виде yaml файла, аналогично манифестам модов:

* `merge_instructions_bulldog.yaml`
```yaml
- commands: data\if\strings\_uidescription.xml    # что объединяем (в файлах мода)
  targets:  if\strings\uidescription.xml          # куда объединяем (в файлах игры)
```
Инструкций в одном файле может быть много, но пока остановимся на этом.


А вот в самом файле с командами нам достаточно указать только новую информацию:

* `_uidescription.xml`
```xml
<?xml version="1.0" encoding="windows-1251" standalone="yes" ?>
<resource>
    <string
        _Action="Add"
        _SelectorKeys="id"
        id="bulldogCab01_diz"
        value="Первая кабина Бульдога, совершенно недостаточное вооружение, но высокая скорость частично компенсирует нехватку огневой мощи."/>
</resource>
```
Если это единственная правка что мы делаем - это и есть полное содержание файла.

Как видим, для простого объекта (или, по другому, xml "нода") - команда очень похожа на сам финальный объект который мы хотим получить.

Правда добавились несколько новых значений (по другому, xml "полей"), имена которых начинаются на нижнее подчёркивание "_".

### Новые технические поля

**_Action** это "действие", тип команды. Мерж-моды поддерживают разные команды для добавления, изменения и удаления xml нодов. Эта, **Add** - "строгое добавление". Почему "строгое"? Потому что команды бывают двух типов. Об этом, однако, чуть позже.

Что же такое **_SelectorKeys**? Тут нам нужно сперва понять как ComMod выполняет мерж-команды. 
Сперва, ComMod пытается понять затрагивает ли команда какой-то существующий нод. Игра в большинстве случаев не терпит объекты с одинаковыми "именами". Но эти "имена" - не везде одинаково записываются. Где-то уникальной достигается через поле "id", как в этом файле. Где-то поле другое, "name". Где-то - уникальность достигается комбинацией двух полей, например отношения между группировками в файле `relationship.xml` задаются через комбинацию двух полей (forwhom, tolerance):

```xml
<relationship>
    ...
    <set
        forwhom="1003"
        who="1004 1008 1009 1010 1011"
        tolerance="neutral" />
    <set
        forwhom="1004"
        who="1003 1008 1009 1010 1011 1014"
        tolerance="neutral" />
    ...
</relationship>
```
Соответственно, если мы создаём команду **Add** для такого файла, мы хотим быть уверены, что установка нашего мода не сломает игру. Где-то правильным решением при конфликте будет перезаписать существующий нод. В других - при нахождении конфликта, надо будет остановить установку мода, сообщить пользователю о несовместимости и откатить изменения.

В других ситуациях никакого уникального способа описать объект вообще нет. Например, магазин города может содержать несколько одинаковых гаджетов. Всё это ComMod пытается понять перед тем как применить команду.

Вернёмся к **_SelectorKeys**. Это поле которое определяет целевой нод для нашей команды. Для команды изменения - цель важна чтобы знать какой нод менять, для команды удаления - чтобы знать какой нод удалить, для команды добавления - чтобы понять можем ли мы добавить новый нод, будет ли он уникальным для нашего "селектора" (от "select", в переводе "выбор").

**_SelectorKeys** это первый способ задать селектор. Он говорит на какие поля нода нужно посмотреть, чтобы определить его уникальность. Для нашего **<string>** нода это как раз поле "id", поэтому _SelectorKeys="id" говорит ComMod что ему безопасно добавить новый нод в наш файл, до тех пор пока там нет другого нода с **id="bulldogCab01_diz"**. О другом способе указать цель команды мы расскажем позже.
Создав команду с таким _SelectorKeys, мы указываем комоду что хотим добавить нод с тегом string и id="bulldogCab01_diz". Если такой нод уже существует в файле - установщику ясно что это конфликт.


### Промежуточный итог

Находить конфликты и откатывать изменения - это работа ComMod и он это умеет. А вот принять решение, нужно ли заменять идентичный нод или в случае конфликта преврать установку и сообщить об ошибке - определяют создатели модов, через выбор правильного типа команды и правильного селектора.

Аналогично и для изменения или удаления. Что если мы создали команду удаления определённой пушки в магазине города, или удаления триггера квеста (поскольку добавили другой, новый, а старый нам более не нужен) - но при обработке команды ComMod понял, что нода который мы хотим удалить, никогда и не существовало? Может быть это нормально? А может быть отсутствие триггера говорит о том что наш новый триггер тоже не заработает? 

Задача авторов модов тут определиться с тем когда использовать какую команду и какую её версию - "строгую" или "мягкую". 

Например:
* **Add** - строгое добавление. Если Add встретит нод, который будет конфликтовать с его селектором в изначальном файле, команда выдаст ошибку и установка мода будет отменена. Игра при этом не будет испорчена, а её файлы не будут частично перезаписаны модом. 
* **AddOrReplace** - мягкая версия добавления. Если она встретит конфликтующий нод, то просто его перезапишет.

В случае нашего мода с новой машиной, можно использовать строгую команду для добавления описания машины. Странно, если копия игры уже содержит описание нашей машины, верно? Возможно кто-то уже включил нашу машину (или другую, с таким же названием) в состав своего мода и игрок установил его ранее, тогда установка поверх нашего мода звучит рецептом для багов.

С другой стороны, если бы наш мод корректировал ещё и характеристику какой-то пушки, возможно, команда изменения характеристик этой пушки может быть мягкой. Ведь если этой пушки не оказалось в игре, нет ничего страшного если мы её не перебалансим.

Узнать подробнее о типах команд, о том как правильно выбрать и сконструировать команду, увидеть больше примеров - можно в последующих статьях раздела.

Так же в отдельной статье расскажем об автоматике, которую предоставляет ComMod для создания "разницы" между двумя файлами, т.е. списка команд который позволяют из одного файла сделать другой. Это незаменимый инструмент для портирования уже готовый модов на систему merge-команд, а так же поможет и в создании новых модов.
